#include "display_pc.h"

#include <stdlib.h>

#include "resources.h"
#include "system.h"

/// Generates the palette textures used by the shader to simulate color palettes
///
/// @param src Pointer to COL banks 0-5 (in one memory bank)
/// @return allocated sfTexture containing all color palettes
sfTexture* gen_col_texture(const u16* const src){
	u8 array[4*256*6]; // no {0} because it will all be generated by the end
	
	for (size_t i = 0; i < 256*6; ++i){
		u16 s = src[i];
//		s = ((s & 0xff00) >> 8) | ((s & 0x00ff) << 8);
		
		array[4*i+0] = (s & 0x001f) << 3; //TODO:IMPL:LOW Adjust values to match PTC
		array[4*i+1] = ((s & 0x03e0) >> 2) | ((s & 0x8000) >> 13);
		array[4*i+2] = ((s & 0x7c00) >> 7);
		if ((i / 256) % 3 != 2){
			// BG, SP
			array[4*i+3] = (i % 16) ? 255 : 0;
		} else {
			// GRP
			array[4*i+3] = (i % 256) ? 255 : 0;
		}
//		iprintf("%ld:(%d,%d,%d,%d)",i,array[4*i+0],array[4*i+1],array[4*i+2],array[4*i+3]);
	}
//	iprintf("\n");
	
	sfTexture* tex = sfTexture_create(256, 6);
	if (!tex){
		return NULL;
	}
	sfTexture_updateFromPixels(tex, array, 256, 6, 0, 0);
	return tex;
}

sfTexture* gen_chr_texture(const u8* const src, const size_t size){
	u8 array[4*size*64];
	for (size_t i = 0; i < size; ++i){
		size_t x = i % 32;
		size_t y = i / 32;
		for (int cx = 0; cx < 8; ++cx){
			for (int cy = 0; cy < 8; ++cy){
				u8 c = src[32*i+cx/2+4*cy];
				array[4*(8*x+cx+256*(8*y+cy))] = ((cx & 1) ? (c >> 4) & 0x0f : c & 0x0f);
			}
		}
	}
	
	sfTexture* tex = sfTexture_create(256, size/4);
	if (!tex){
		return NULL;
	}
	sfTexture_updateFromPixels(tex, array, 256, size/4, 0, 0);
	return tex;
}

void init_display(struct ptc* p){
	struct display* d = &p->display;
	struct resources* r = &p->res;
	
	d->console_map = init_tilemap(CONSOLE_WIDTH, CONSOLE_HEIGHT);
	d->console_bg_map = init_tilemap(CONSOLE_WIDTH, CONSOLE_HEIGHT);
	d->panel_text_map = init_tilemap(CONSOLE_WIDTH, CONSOLE_HEIGHT);
	d->panel_bg_map = init_tilemap(CONSOLE_WIDTH, CONSOLE_HEIGHT);
	
	d->graphic = init_graphic(GRP_WIDTH, GRP_HEIGHT);
	
	d->background_map = init_tilemap(BG_WIDTH, BG_HEIGHT);
//	d->foreground_map = init_tilemap(BG_WIDTH, BG_HEIGHT);
	
//	d->sprites = init_sprite_array();
//	d->panel_keys = init_sprite_array();
	
	// SFML stuff
	d->view = sfView_createFromRect((sfFloatRect){0, 0, 256, 192});
	sfView_setViewport(d->view, (sfFloatRect){0, 0, 1, 0.5f});
	
	// actual draw commands
	d->rs = sfRenderStates_default();
	if (!sfShader_isAvailable()){
		iprintf("Error: Shaders are unavailable!\n");
		abort();
	} else {
		if (!(d->shader = sfShader_createFromFile(NULL, NULL, "resources/bgsp.frag"))){
			iprintf("Error: Shader failed to load!\n");
			abort();
		}
	}
	
	// Generate PC textures here
	for (int page = 0; page <= 1; ++page){
		d->chr_tex[0+5*page] = gen_chr_texture(r->chr[0+CHR_BANKS*page], 512); //BGF
		d->chr_tex[1+5*page] = gen_chr_texture(r->chr[4+CHR_BANKS*page], 1024); //BGD
		d->chr_tex[2+5*page] = gen_chr_texture(r->chr[8+CHR_BANKS*page], 1024); //BGU
		d->chr_tex[3+5*page] = gen_chr_texture(r->chr[12+CHR_BANKS*page], 2048); // SPU or SPD
		d->chr_tex[4+5*page] = gen_chr_texture(r->chr[20+CHR_BANKS*page], 512); //SPS
	}
	// Generates all colors at once
	d->col_tex = gen_col_texture(r->col_banks);
}

void free_display(struct display* d){
	free_tilemap(&d->console_map);
	free_tilemap(&d->console_bg_map);
	free_tilemap(&d->panel_bg_map);
	free_tilemap(&d->panel_text_map);
	
	free_graphic(&d->graphic);
	
	free_tilemap(&d->background_map);
//	free_tilemap(&d->foreground_map);
	
//	free_sprite_array(d->sprites);
//	free_sprite_array(d->panel_keys);
	
	sfView_destroy(d->view);
	
	// Destroy textures here
	for (int i = 0; i < 10; ++i){
		sfTexture_destroy(d->chr_tex[i]);
	}
	sfTexture_destroy(d->col_tex);
	sfShader_destroy(d->shader);
}

void display_draw_all(struct ptc* p){
	// SFML stuff
	struct display* d = &p->display;
	struct resources* r = &p->res;
//	d->view = sfView_createFromRect((sfFloatRect){0, 0, 256, 192});
//	sfView_setViewport(d->view, (sfFloatRect){0, 0, 1, 0.5f});
//	sfRenderWindow_setView(d->rw, d->view);
	
	// actual draw commands
	d->rs = sfRenderStates_default();
	sfShader* shader = p->display.shader;

	d->rs.shader = shader;
	
	sfShader_setFloatUniform(shader, "colbank", 0);
	
	sfRenderWindow_clear(d->rw, sfBlack);
	
	// TODO:PERF:MED Reuse texture memory instead of destroying and regenerating
	for (int page = 0; page <= 1; ++page){
		if (r->regen_chr[0 + CHR_BANKS * page] || r->regen_chr[1 + CHR_BANKS * page]){
			sfTexture_destroy(d->chr_tex[0+5*page]);
			d->chr_tex[0+5*page] = gen_chr_texture(r->chr[0+CHR_BANKS*page], 512); //BGF
			r->regen_chr[0 + CHR_BANKS * page] = false;
			r->regen_chr[1 + CHR_BANKS * page] = false;
		}
		if (r->regen_chr[4 + CHR_BANKS * page] ||
			r->regen_chr[5 + CHR_BANKS * page] ||
			r->regen_chr[6 + CHR_BANKS * page] ||
			r->regen_chr[7 + CHR_BANKS * page])
		{
			sfTexture_destroy(d->chr_tex[1+5*page]);
			d->chr_tex[1+5*page] = gen_chr_texture(r->chr[4+CHR_BANKS*page], 1024); //BGD
			r->regen_chr[4 + CHR_BANKS * page] = false;
			r->regen_chr[5 + CHR_BANKS * page] = false;
			r->regen_chr[6 + CHR_BANKS * page] = false;
			r->regen_chr[7 + CHR_BANKS * page] = false;
		}
		if (r->regen_chr[8 + CHR_BANKS * page] ||
			r->regen_chr[9 + CHR_BANKS * page] ||
			r->regen_chr[10 + CHR_BANKS * page] ||
			r->regen_chr[11 + CHR_BANKS * page])
		{
			sfTexture_destroy(d->chr_tex[2+5*page]);
			d->chr_tex[2+5*page] = gen_chr_texture(r->chr[8+CHR_BANKS*page], 1024); //BGU
			r->regen_chr[8 + CHR_BANKS * page] = false;
			r->regen_chr[9 + CHR_BANKS * page] = false;
			r->regen_chr[10 + CHR_BANKS * page] = false;
			r->regen_chr[11 + CHR_BANKS * page] = false;
		}
		if (r->regen_chr[12 + CHR_BANKS * page] ||
			r->regen_chr[13 + CHR_BANKS * page] ||
			r->regen_chr[14 + CHR_BANKS * page] ||
			r->regen_chr[15 + CHR_BANKS * page] ||
			r->regen_chr[16 + CHR_BANKS * page] ||
			r->regen_chr[17 + CHR_BANKS * page] ||
			r->regen_chr[18 + CHR_BANKS * page] ||
			r->regen_chr[19 + CHR_BANKS * page])
		{
			sfTexture_destroy(d->chr_tex[3+5*page]);
			d->chr_tex[3+5*page] = gen_chr_texture(r->chr[12+CHR_BANKS*page], 2048); // SPU or SPD
			r->regen_chr[12 + CHR_BANKS * page] = false;
			r->regen_chr[13 + CHR_BANKS * page] = false;
			r->regen_chr[14 + CHR_BANKS * page] = false;
			r->regen_chr[15 + CHR_BANKS * page] = false;
			r->regen_chr[16 + CHR_BANKS * page] = false;
			r->regen_chr[17 + CHR_BANKS * page] = false;
			r->regen_chr[18 + CHR_BANKS * page] = false;
			r->regen_chr[19 + CHR_BANKS * page] = false;
		}
		if (r->regen_chr[20 + CHR_BANKS * page] ||
			r->regen_chr[21 + CHR_BANKS * page])
		{
			sfTexture_destroy(d->chr_tex[4+5*page]);
			d->chr_tex[4+5*page] = gen_chr_texture(r->chr[20+CHR_BANKS*page], 512); //SPS
			r->regen_chr[20 + CHR_BANKS * page] = false;
			r->regen_chr[21 + CHR_BANKS * page] = false;
		}
	}
	
	if (r->regen_col){
		sfTexture_destroy(d->col_tex);
		d->col_tex = gen_col_texture(r->col_banks);
		r->regen_col = false;
	}
	
	sfShader_setTextureUniform(shader, "colors", d->col_tex);
	sfShader_setCurrentTextureUniform(shader, "texture");
	
	// =============
	// Upper screen
	// =============
	sfView_setViewport(d->view, (sfFloatRect){0, 0, 1, 0.5f});
	sfRenderWindow_setView(d->rw, d->view);
	
	// lowest prio
	display_graphics(p, 0, 3);
	display_sprite(p, 0, 3);
	display_background(p, 0, 1);
	display_graphics(p, 0, 2);
	display_sprite(p, 0, 2);
	display_background(p, 0, 0);
	display_graphics(p, 0, 1);
	display_sprite(p, 0, 1);
	display_console(p);
	display_graphics(p, 0, 0);
	display_sprite(p, 0, 0);
	display_cursor(p);
	// highest prio
	
	// =============
	// Lower screen
	// =============
	sfView_setViewport(d->view, (sfFloatRect){0, 0.5f, 1, 0.5f});
	sfRenderWindow_setView(d->rw, d->view);
	// lowest prio
	
	display_graphics(p, 1, 3);
	display_sprite(p, 1, 3);
	display_background(p, 1, 1);
	display_graphics(p, 1, 2);
	display_sprite(p, 1, 2);
	display_background(p, 1, 0);
	display_graphics(p, 1, 1);
	display_sprite(p, 1, 1);
	display_panel_background(p);
	display_panel_keys(p); // TODO:TEST:LOW Check that panel priority here is actually correct
	display_panel_console(p);
	display_graphics(p, 1, 0);
	display_sprite(p, 1, 0);
	display_icon(p);
	// highest prio
	
	sfRenderWindow_display(d->rw);
}

/// Helper function to update the SFML rendering state.
void draw_va(struct display* d, int col, int tex, sfVertexArray* va){
	d->rs.texture = d->chr_tex[tex];
	sfShader_setFloatUniform(d->shader, "colbank", col);
	sfShader_setBoolUniform(d->shader, "grp_mode", col == SBC_COL_GRP_LOWER || col == SBC_COL_GRP_UPPER);
	sfRenderWindow_drawVertexArray(d->rw, va, &d->rs);
}

/// Draws the upper screen text console foreground and background.
///
/// Display of the foreground can be toggled with `VISIBLE`.
/// The color background cannot be disabled.
void display_console(struct ptc* p){
	struct display* d = &p->display;
	// Update the tilemaps
	for (int x = 0; x < CONSOLE_WIDTH; ++x){
		for (int y = 0; y < CONSOLE_HEIGHT; ++y){
			tile(&d->console_map, x, y, to_char(con_text_getc(&p->console, x, y)), 0, 0);
			palette(&d->console_map, x, y, con_col_get(&p->console, x, y) & COL_FG_MASK);
			
			u8 c = (con_col_get(&p->console, x, y) & COL_BG_MASK) >> 4;
			tile(&d->console_bg_map, x, y, c ? 15 : 0, 0, 0);
			palette(&d->console_bg_map, x, y, c);
		}
	}
	
	// Background color layer
	draw_va(d, SBC_COL_BG_UPPER, SBC_TEX_BGD_UPPER, d->console_bg_map.va);
	// Text layer
	if (p->res.visible & VISIBLE_CONSOLE){
		draw_va(d, SBC_COL_BG_UPPER, SBC_TEX_BGF_UPPER, d->console_map.va);
	}
}

void display_panel_console(struct ptc* p){
	struct display* d = &p->display;
	// Update the tilemaps
	for (int x = 0; x < CONSOLE_WIDTH; ++x){
		for (int y = 0; y < CONSOLE_HEIGHT; ++y){
			struct console* c = p->panel.keys_text; // function key text
			if (p->panel.type == PNL_OFF || p->panel.type == PNL_PNL){
				// lower screen text console
				c = p->panel.text;
			}
			tile(&d->panel_text_map, x, y, to_char(con_text_getc(c, x, y)), 0, 0);
			palette(&d->panel_text_map, x, y, con_col_get(c, x, y) & COL_FG_MASK);
		}
	}
	
	draw_va(d, SBC_COL_BG_LOWER, SBC_TEX_BGF_LOWER, d->panel_text_map.va);
}

void display_background(struct ptc* p, int screen, int layer){
	// Check if these should even be rendered
	if (!(p->res.visible & VISIBLE_BG0) && layer == 0) return;
	if (!(p->res.visible & VISIBLE_BG1) && layer == 1) return;
	struct display* d = &p->display;
	
	// TODO:IMPL:MED BGCLIP bounds
	// It's trickier than you'd think due to weird wrapping rules...
//	sfView_setViewport(d->view, (sfFloatRect){0, screen * 0.5f, 1, 0.5f});
//	sfRenderWindow_setView(d->rw, d->view);
	// 0 - 7 -> 0
	// tile unit to start at
	int start_x = (uint32_t)(FP_TO_INT(p->background.ofs[screen][layer].x) / 8) % BG_WIDTH;
	int start_y = (uint32_t)(FP_TO_INT(p->background.ofs[screen][layer].y) / 8) % BG_HEIGHT;
	// offset within tile
	float ofs_x = (uint32_t)(FP_TO_INT(p->background.ofs[screen][layer].x)) % 8;
	float ofs_y = (uint32_t)(FP_TO_INT(p->background.ofs[screen][layer].y)) % 8;
	
	// at most 33 tiles can be displayed in x direction
	// 25 in y direction
	for (int x = 0; x < SCREEN_WIDTH / CHR_WIDTH + 1; ++x){
		for (int y = 0; y < SCREEN_HEIGHT / CHR_HEIGHT + 1; ++y){
			u16 td = bg_tile(p,screen,layer,(x + start_x) % BG_WIDTH,(y + start_y) % BG_HEIGHT);
			tile(&d->background_map, x, y, td & 0x3ff, (td & 0x400) >> 10, (td & 0x800) >> 11);
			palette(&d->background_map, x, y, (td & 0xf000) >> 12);
		}
	}
	
	// translate layer
	sfTransform_translate(&d->rs.transform, -ofs_x, -ofs_y);
	draw_va(d,
		screen ? SBC_COL_BG_LOWER : SBC_COL_BG_UPPER,
		screen ? SBC_TEX_BGU_LOWER : SBC_TEX_BGU_UPPER,
		d->background_map.va
	);
	// reset transform
	d->rs.transform = sfTransform_Identity;
}

void display_panel_background(struct ptc* p){
	struct display* d = &p->display;
	if (p->panel.type == PNL_OFF) return;
	if (!(p->res.visible & VISIBLE_PANEL)) return;
	
	for (int x = 0; x < CONSOLE_WIDTH; ++x){
		for (int y = 0; y < CONSOLE_HEIGHT; ++y){
			// Panel BG map
			u16 td = p->res.scr[SCR_BANKS+1][x+CONSOLE_WIDTH*y];
			tile(&d->panel_bg_map, x, y, td & 0x3ff, (td & 0x400) >> 10, (td & 0x800) >> 11);
			palette(&d->panel_bg_map, x, y, (td & 0xf000) >> 12);
		}
	}
	draw_va(d, SBC_COL_BG_LOWER, SBC_TEX_BGD_LOWER, d->panel_bg_map.va);
}

void display_sprite(struct ptc* p, int screen, int prio){
	// Don't display over panel
	if (screen == 1 && (p->panel.type != PNL_OFF || !(p->res.visible & VISIBLE_PANEL))) return;
	if (!(p->res.visible & VISIBLE_SPRITE)) return;
	
	struct display* d = &p->display;
	// TODO:PERF:NONE re-use this to prevent extra allocations?
	struct sprite_array sprites = init_sprite_array();
	
	for (int i = 0; i < MAX_SPRITES; ++i){
		if (p->sprites.info[screen][i].active && p->sprites.info[screen][i].prio == prio){
			add_sprite(sprites, &p->sprites.info[screen][i]);
		}
	}
	
	draw_va(d, 
		screen ? SBC_COL_SPR_LOWER : SBC_COL_SPR_UPPER,
		screen ? SBC_TEX_SPS_LOWER : SBC_TEX_SPU_UPPER,
		sprites.va
	);
	
	free_sprite_array(sprites);
}

void display_panel_keys(struct ptc* p){
	// Only render keyboard when enabled
	if (p->panel.type == PNL_OFF || p->panel.type == PNL_PNL) return;
	if (!(p->res.visible & VISIBLE_PANEL)) return;
	
	struct display* d = &p->display;
	// TODO:PERF:NONE re-use this to prevent extra allocations?
	struct sprite_array sprites = init_sprite_array();
	
	if (p->panel.key_pressed){
		offset_key(p, p->panel.id_pressed, INT_TO_FP(1));
	}
	
	for (int i = 0; i < KEYBOARD_KEYS; ++i){
		struct sprite_info* key = &p->panel.keys[i];
		// active is a good check to see if the sprite is correctly defined, for now
		if (key->active){
			add_sprite(sprites, key);
		}
	}
	
	if (p->panel.key_pressed){
		offset_key(p, p->panel.id_pressed, INT_TO_FP(-1));
	}
	
	draw_va(d, SBC_COL_SPR_LOWER, SBC_TEX_SPD_LOWER, sprites.va);
	
	free_sprite_array(sprites);
}

void display_icon(struct ptc* p){
	struct display* d = &p->display;
	// Icons are basically always rendered
	struct sprite_array icon_sprites = init_sprite_array();
	
	if (p->panel.key_pressed){
		offset_key(p, p->panel.id_pressed, INT_TO_FP(1));
	}
	
	for (int i = 0; i < ICON_KEYS; ++i){
		struct sprite_info* key = &p->panel.keys[ICON_PAGE_START+i];
		// active is a good check to see if the sprite is correctly defined, for now
		if (key->active){
			add_sprite(icon_sprites, key);
		}
	}
	
	if (p->panel.key_pressed){
		offset_key(p, p->panel.id_pressed, INT_TO_FP(-1));
	}
	draw_va(d, SBC_COL_SPR_LOWER, SBC_TEX_SPD_LOWER, icon_sprites.va);
	
	free_sprite_array(icon_sprites);
}

void display_cursor(struct ptc* p){
	if (!p->console.cursor_visible) return;
	struct display* d = &p->display;
	
	struct sprite_array cursor_sprite = init_sprite_array();
	struct sprite_info cursor = init_sprite_info(100,108,0,0,0,0,8,8);
	cursor.pos.x = INT_TO_FP(p->console.x * 8);
	cursor.pos.y = INT_TO_FP(p->console.y * 8);
	
	add_sprite(cursor_sprite, &cursor);
	
	draw_va(d, SBC_COL_SPR_UPPER, SBC_TEX_SPS_UPPER, cursor_sprite.va);
	
	free_sprite_array(cursor_sprite);
}

void display_graphics(struct ptc* p, int screen, int prio){
	if (screen == 1 && !(p->panel.type == PNL_OFF || p->panel.type == PNL_PNL)) return;
	if (screen == 1 && !(p->res.visible & VISIBLE_PANEL)) return;
	if (!(p->res.visible & VISIBLE_GRAPHICS)) return;
	
	struct display* d = &p->display;
	if (prio == p->graphics.info[screen].prio){
		draw_graphic(&d->graphic, p, screen);
		
		sfShader_setFloatUniform(d->shader, "colbank", 2+3*screen);
		sfShader_setBoolUniform(d->shader, "grp_mode", true);
		sfRenderWindow_drawSprite(d->rw, d->graphic.sprite, &d->rs);
	}
}

